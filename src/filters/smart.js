import Filter from '../lib/filter.js';
import Conversions from '../lib/conversions.js';
import Band from '../lib/band.js';

/**
 * Smart sorting filter. Uses edge-detection to sort pixels in regions.
 * @extends Filter
 */
class Smart extends Filter {
  /**
   * Run Smart filter on image.
   * @override
   * @param {Image} image
   * @param {Object} options
   * @param {number} options.threshold - Used to combine like-pixels into bands. 0 means no combination. Higher numbers collect more pixels.
   * @param {string} options.method - Sorting method.
   * @param {int} options.middlate - Middlation effect counter. 0 means no run. > 0 means loop that many times. < 0 means run middlateReverse than many times.
   * @param {(truthy|'either')} options.reverse - Reverse string or not. Providing 'either' will randomly reverse lines.
   * @param {string} options.direction - Direction to sort in. Options are: horizontal, vertical, tlbr (top-left to bottom-right diagonal), or trbl (top-right to bottom-left diagonal).
   * @return {Image} image
   */
  static run(image, {
    threshold = 20,
    method = 'sumRGBA',
    middlate = 0,
    reverse = false,
    direction = 'horizontal',
  } = {}) {
    let lines = image.getLines(direction);
    const sobelMap = this.sobelize(image);
    const modifyLine = (line, key) => {
      const newLine = [];
      const bands = this.edgeBands(
        sobelMap,
        direction,
        threshold,
        image.width,
        +key,
        line
      );
      bands.forEach((band) => {
        band.sortByMethod(method);
        if (
          reverse === true ||
          (reverse === 'either' && Math.round(Math.random()) === 1)
        ) {
          band.reverse();
        }
        band.middlateLoop(middlate);
        newLine.push(...band.pixels);
      });
      return newLine;
    };
    if (direction === 'vertical' || direction === 'horizontal') {
      lines = lines.map(modifyLine);
    } else {
      Object.entries(lines).forEach(([key, line]) => {
        lines[key] = modifyLine(line, key);
      });
    }
    image.setLines(direction, lines);
    return image;
  }

  /**
   * Generate bands based on edge detection.
   * @param {Array<Array<float>>} sobelMap - Map of sobel values generated by sobelize function.
   * @param {string} direction - Direction sorting in.
   * @param {number} threshold - Used to combine like-pixels into bands. 0 means no combination. Higher numbers collect more pixels.
   * @param {int} columns - Width of the image. Used for conversions.
   * @param {int} key - Key for the current line operating on.
   * @param {Array<Onecolor>} line - Set of pixels to turn into bands.
   * @return {Array<Band>} Bands
   */
  static edgeBands(sobelMap, direction, threshold, columns, key, line) {
    const getSobel = (() => {
      switch (direction) {
        case 'horizontal':
          return ((key, i) => sobelMap[key][i]);
        case 'vertical':
          return ((key, i) => sobelMap[i][key]);
        case 'tlbr':
          return ((key, i) => {
            const {x, y} = Conversions.tlbrDiagonalToXY(key, i);
            return sobelMap[y][x];
          });
        case 'trbl':
          return ((key, i) => {
            const {x, y} = Conversions.trblDiagonalToXY(key, i, columns);
            return sobelMap[y][x];
          });
      }
    })();
    let prevSobel = 0;
    const bands = [];
    let currBand = new Band([]);
    for (let i = 0; i < line.length; i++) {
      const currSobel = getSobel(key, i);
      if (Math.abs(currSobel - prevSobel) <= threshold) {
        currBand.pixels.push(line[i]);
      } else {
        bands.push(currBand);
        currBand = new Band([line[i]]);
      }
      prevSobel = currSobel;
    }
    bands.push(currBand);
    return bands;
  }

  /**
   * Generate sobel values from image.
   * @see {@link https://en.wikipedia.org/wiki/Sobel_operator}
   * @param {Image} image
   * @return {Array<Array<float>>} - Multidimensional sobel map.
   */
  static sobelize(image) {
    const sobelX = [
      [1, 0, -1],
      [2, 0, -2],
      [1, 0, -1],
    ];
    const sobelY = [
      [1, 2, 1],
      [0, 0, 0],
      [-1, -2, -1],
    ];
    const grey = image.image.clone().greyscale();
    const sobelMap = [];
    grey.scan(0, 0, image.width, image.height, (x, y, idx) => {
      let sumX = 0;
      let sumY = 0;
      if (x === 0) {
        sobelMap.push([]);
      }
      for (let iy = -1; iy <= 1; iy++) {
        const _y = iy + y;
        if (_y < 0 || _y >= image.height) continue;
        for (let ix = -1; ix <= 1; ix++) {
          const _x = ix + x;
          if (_x < 0 || _x >= image.width) continue;
          const idxi = grey.getPixelIndex(_x, _y);
          // Red value + alpha value
          const rav = grey.bitmap.data[idxi] + grey.bitmap.data[idxi + 3];
          sumX += sobelX[iy + 1][ix + 1] * rav;
          sumY += sobelY[iy + 1][ix + 1] * rav;
        }
      }
      sobelMap[y][x] = Math.sqrt(Math.pow(sumX, 2) + Math.pow(sumY, 2));
    });
    return sobelMap;
  }
}

module.exports = Smart;
